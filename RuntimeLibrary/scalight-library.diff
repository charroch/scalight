diff --git a/src/library/scala/Product.scala b/src/library/scala/Product.scala
index 1459ab9..33d3e02 100644
--- a/src/library/scala/Product.scala
+++ b/src/library/scala/Product.scala
@@ -35,7 +35,7 @@ trait Product extends Any with Equals {
   /** An iterator over all the elements of this product.
    *  @return     in the default implementation, an `Iterator[Any]`
    */
-  def productIterator: Iterator[Any] = new collection.AbstractIterator[Any] {
+  def productIterator: java.util.Iterator[Any] = new java.util.Iterator[Any] {
     private var c: Int = 0
     private val cmax = productArity
     def hasNext = c < cmax
diff --git a/src/library/scala/reflect/api/Trees.scala b/src/library/scala/reflect/api/Trees.scala
index ca4e60f..9757d46 100644
--- a/src/library/scala/reflect/api/Trees.scala
+++ b/src/library/scala/reflect/api/Trees.scala
@@ -7,6 +7,7 @@ package scala.reflect
 package api
 
 import scala.collection.mutable.ListBuffer
+import collection.JavaConversions._
 
 // Syncnote: Trees are currently not thread-safe.
 trait Trees { self: Universe =>
diff --git a/src/library/scala/runtime/ScalaRunTime.scala b/src/library/scala/runtime/ScalaRunTime.scala
index 4c5e0e4..a0e7473 100644
--- a/src/library/scala/runtime/ScalaRunTime.scala
+++ b/src/library/scala/runtime/ScalaRunTime.scala
@@ -196,14 +196,24 @@ object ScalaRunTime {
     }
   }
 
-  def _toString(x: Product): String =
-    x.productIterator.mkString(x.productPrefix + "(", ",", ")")
+  def mkString(it: java.util.Iterator[Any], prefix: String, sep: String, suffix: String): String = {
+    val b = new StringBuilder(prefix)
+    while (it.hasNext) {
+      b.append(it.next)
+      if (it.hasNext)
+        b.append(sep)
+    }
+    b.append(suffix)
+    b.toString
+  }
+  def _toString(x: Product): String = 
+    mkString(x.productIterator, x.productPrefix + "(", ",", ")")
 
   def _hashCode(x: Product): Int = scala.util.MurmurHash3.productHash(x)
 
   /** A helper for case classes. */
-  def typedProductIterator[T](x: Product): Iterator[T] = {
-    new AbstractIterator[T] {
+  def typedProductIterator[T](x: Product): java.util.Iterator[T] = {
+    new java.util.Iterator[T] {
       private var c: Int = 0
       private val cmax = x.productArity
       def hasNext = c < cmax
@@ -225,7 +235,7 @@ object ScalaRunTime {
     else x.equals(y)
 
   def _equals(x: Product, y: Any): Boolean = y match {
-    case y: Product if x.productArity == y.productArity => x.productIterator sameElements y.productIterator
+    case y: Product if x.productArity == y.productArity => sameElements(x.productIterator, y.productIterator)
     case _                                              => false
   }
 
@@ -280,6 +290,20 @@ object ScalaRunTime {
    *  See ticket #2867 for specifics.
    */
   def sameElements(xs1: collection.Seq[Any], xs2: collection.Seq[Any]) = xs1 sameElements xs2
+  
+  def map(xs: java.util.Iterator[Any], f: Any => Any): java.util.Iterator[Any] = { 
+    new java.util.Iterator[Any] {
+      def hasNext = xs.hasNext
+      def next = f(xs.next)
+    }
+  }
+  def sameElements(xs1: java.util.Iterator[Any], xs2: java.util.Iterator[Any]): Boolean = { 
+    while (xs1.hasNext && xs2.hasNext)
+      if (xs1.next != xs2.next)
+        return false
+
+    !xs1.hasNext && !xs2.hasNext
+  }
 
   /** Given any Scala value, convert it to a String.
    *
@@ -350,7 +374,7 @@ object ScalaRunTime {
       case x: Iterable[_]               => x.iterator take maxElements map inner mkString (x.stringPrefix + "(", ", ", ")")
       case x: Traversable[_]            => x take maxElements map inner mkString (x.stringPrefix + "(", ", ", ")")
       case x: Product1[_] if isTuple(x) => "(" + inner(x._1) + ",)" // that special trailing comma
-      case x: Product if isTuple(x)     => x.productIterator map inner mkString ("(", ",", ")")
+      case x: Product if isTuple(x)     => mkString(map(x.productIterator, inner(_)), "(", ",", ")")
       case x                            => x.toString
     }
 
